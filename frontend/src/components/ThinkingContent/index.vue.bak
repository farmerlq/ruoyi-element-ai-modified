<template>
  <div class="thinking-content-container">
    <div class="thinking-header" @click="toggleCollapse">
      <el-icon class="thinking-icon"><Lightning /></el-icon>
      <span class="thinking-title">AI 思考过程</span>
      <el-tag type="info" size="small" class="thinking-tag">点击展开/收起</el-tag>
      <el-icon class="collapse-icon" :class="{ 'is-collapsed': isCollapsed }">
        <ArrowDown />
      </el-icon>
    </div>
    
    <div v-show="!isCollapsed" class="thinking-content">
      <transition name="fadeIn" appear>
        <div v-if="contentBlocks && contentBlocks.length > 0" class="formatted-content">
          <div 
            v-for="(block, index) in contentBlocks" 
            :key="index"
            class="content-block"
            :class="block.type"
          >
            <div v-if="block.type === 'text'" class="text-block" v-html="formatText(block.content)"></div>
            <div v-else-if="block.type === 'tool'" class="tool-block">
              <div class="tool-header" @click="toggleToolCollapse(index)">
                <el-icon class="tool-icon"><Operation /></el-icon>
                <span class="tool-name">使用工具： {{ block.name }}</span>
                <span v-if="(block.input || block.output)" class="tool-data-toggle">
                  {{ block.collapsed ? '展开' : '收起' }}
                </span>
                <el-icon class="collapse-icon" :class="{ 'is-collapsed': block.collapsed }">
                  <ArrowDown />
                </el-icon>
              </div>
              <transition name="slideDown">
                <div v-show="!block.collapsed" class="tool-details">
                  <div v-if="block.input" class="tool-section">
                    <div class="section-title">请求</div>
                    <pre class="tool-input-json" v-html="formatJson(block.input)"></pre>
                  </div>
                  <div v-if="block.output" class="tool-section">
                    <div class="section-title">响应</div>
                    <pre class="tool-output-json" v-html="formatJson(block.output)"></pre>
                  </div>
                </div>
              </transition>
            </div>
            <div v-else-if="block.type === 'files'" class="files-block">
              <div class="files-header" @click="toggleFilesCollapse(index)">
                <el-icon class="files-icon"><FolderOpened /></el-icon>
                <span class="files-title">引用文件</span>
                <el-icon class="collapse-icon" :class="{ 'is-collapsed': block.collapsed }">
                  <ArrowDown />
                </el-icon>
              </div>
              <transition name="slideDown">
                <div v-show="!block.collapsed" class="files-list">
                  <div v-for="(file, fileIndex) in block.files" :key="fileIndex" class="file-item">
                    <el-icon class="file-icon"><Document /></el-icon>
                    {{ file }}
                  </div>
                </div>
              </transition>
            </div>
          </div>
        </div>
        <div v-else class="empty-content">
          <el-icon class="empty-icon"><HelpFilled /></el-icon>
          <span>暂无思考内容</span>
        </div>
      </transition>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch, nextTick } from 'vue'
import { Lightning, Operation, FolderOpened, ArrowDown, Document, HelpFilled } from '@element-plus/icons-vue'

interface ContentBlock {
  type: 'text' | 'tool' | 'files'
  content?: string
  name?: string
  input?: string
  output?: string
  files?: string[]
  collapsed?: boolean
}

const props = defineProps<{
  content: string
}>()

const isCollapsed = ref(false)
const contentBlocks = ref<ContentBlock[]>([])

const toggleCollapse = () => {
  isCollapsed.value = !isCollapsed.value
}

const toggleToolCollapse = (index: number) => {
  const block = contentBlocks.value[index]
  if (block && block.type === 'tool') {
    block.collapsed = !block.collapsed
  }
}

const toggleFilesCollapse = (index: number) => {
  const block = contentBlocks.value[index]
  if (block && block.type === 'files') {
    block.collapsed = !block.collapsed
  }
}

const formatText = (text: string | undefined) => {
  if (!text) return ''
  return text.replace(/\n/g, '<br>')
}

const formatJson = (json: string | undefined) => {
  if (!json) return ''
  try {
    // 尝试解析 JSON
    let parsed
    let cleanedJson = json
    
    // 处理可能的转义字符
    if (typeof cleanedJson === 'string' && cleanedJson.trim()) {
      cleanedJson = cleanedJson.trim()
      
      // 如果JSON已经被字符串化了（包含在引号内），尝试去除引号
      if ((cleanedJson.startsWith('"') && cleanedJson.endsWith('"')) || 
          (cleanedJson.startsWith('\'') && cleanedJson.endsWith('\''))) {
        cleanedJson = cleanedJson.substring(1, cleanedJson.length - 1)
        // 处理内部的转义引号
        cleanedJson = cleanedJson.replace(/\\"/g, '"').replace(/\\\'/g, '\'')
      }
      
      // 处理JSON中的转义换行符和制表符
      cleanedJson = cleanedJson.replace(/\\n/g, '\n').replace(/\\t/g, '\t')
      
      try {
        parsed = JSON.parse(cleanedJson)
        // 如果解析成功，使用正确的美化格式返回
        const formattedJson = JSON.stringify(parsed, null, 2)
        // 确保换行符正确显示
        return formattedJson.replace(/\n/g, '\\n')
      } catch (e) {
        // 如果仍然解析失败，检查是否是简单对象格式
        if (cleanedJson.startsWith('{') && cleanedJson.endsWith('}')) {
          try {
            // 尝试修复可能的格式问题
            const fixedJson = cleanedJson.replace(/([a-zA-Z0-9_]+):/g, '"$1":').replace(/'([^']*)'/g, '"$1"')
            parsed = JSON.parse(fixedJson)
            // 如果修复后解析成功，使用正确的美化格式返回
            const formattedJson = JSON.stringify(parsed, null, 2)
            return formattedJson.replace(/\n/g, '\\n')
          } catch {
            // 如果所有解析尝试都失败，返回原始文本，但处理换行符
            return cleanedJson.replace(/\n/g, '\\n')
          }
        } else {
          // 返回原始文本，但处理换行符
          return cleanedJson.replace(/\n/g, '\\n')
        }
      }
    } else {
      parsed = json
      // 对于非字符串JSON数据，直接格式化
      const formattedJson = JSON.stringify(parsed, null, 2)
      return formattedJson.replace(/\n/g, '\\n')
    }
  } catch (error) {
    // 如果不是有效的 JSON，返回原始文本，但处理换行符
    return (typeof json === 'string' ? json : JSON.stringify(json)).replace(/\n/g, '\\n')
  }
}

// 添加防抖函数，避免频繁更新
let updateTimer: number | null = null
const debouncedUpdateContentBlocks = () => {
  if (updateTimer) {
    clearTimeout(updateTimer)
  }
  updateTimer = window.setTimeout(() => {
    updateContentBlocks()
    updateTimer = null
  }, 100) // 100ms防抖延迟
}

const updateContentBlocks = () => {
  if (!props.content) {
    contentBlocks.value = []
    return
  }
  
  const blocks: ContentBlock[] = []
  const lines = props.content.split('\n')
  let currentBlock: ContentBlock | null = null
  let currentToolName = ''
  let currentToolInput = ''
  let currentToolOutput = ''
  
  for (const line of lines) {
    const trimmedLine = line.trim()
    
    // 检查是否是新的工具调用开始
    if (trimmedLine.includes('使用工具:') || trimmedLine.includes('使用工具：')) {
      // 保存之前的块
      if (currentBlock) {
        blocks.push(currentBlock)
        currentBlock = null
      }
      
      // 保存之前的工具块（如果有）
      if (currentToolName) {
        blocks.push({
          type: 'tool',
          name: currentToolName,
          input: currentToolInput.trim() || undefined,
          output: currentToolOutput.trim() || undefined,
          collapsed: false  // 默认展开工具调用信息
        })
        currentToolName = ''
        currentToolInput = ''
        currentToolOutput = ''
      }
      
      // 提取工具名
      const toolMatch = trimmedLine.match(/使用工具[:：]\s*(.+)/)
      currentToolName = toolMatch ? toolMatch[1].trim() : '未知工具'
      currentToolInput = ''
      currentToolOutput = ''
    }
    // 检查是否是工具参数开始
    else if (currentToolName && (trimmedLine.includes('参数:') || trimmedLine.includes('参数：'))) {
      const paramMatch = trimmedLine.match(/参数[:：]\s*(.+)/)
      if (paramMatch) {
        currentToolInput += paramMatch[1].trim() + '\n'
      }
    }
    // 检查是否是工具响应开始
    else if (currentToolName && (trimmedLine.includes('响应:') || trimmedLine.includes('响应：'))) {
      const responseMatch = trimmedLine.match(/响应[:：]\s*(.+)/)
      if (responseMatch) {
        currentToolOutput += responseMatch[1].trim() + '\n'
      }
    }
    // 检查是否是文件引用开始
    else if (trimmedLine.includes('引用文件') || trimmedLine.includes('文件引用')) {
      // 保存之前的块
      if (currentBlock) {
        blocks.push(currentBlock)
      }
      // 保存工具块（如果有）
      if (currentToolName) {
        blocks.push({
          type: 'tool',
          name: currentToolName,
          input: currentToolInput.trim() || undefined,
          output: currentToolOutput.trim() || undefined,
          collapsed: false  // 默认展开工具调用信息
        })
        currentToolName = ''
        currentToolInput = ''
        currentToolOutput = ''
      }
      
      currentBlock = {
        type: 'files',
        files: [],
        collapsed: false  // 默认展开文件引用
      }
    }
    // 处理文件列表项
    else if (currentBlock && currentBlock.type === 'files' && 
             (trimmedLine.startsWith('-') || trimmedLine.startsWith('*') || /^\d+\./.test(trimmedLine))) {
      const fileName = trimmedLine.replace(/^[\d\-\*\s\.]+/, '').trim()
      if (fileName && currentBlock.files) {
        currentBlock.files.push(fileName)
      }
    }
    // 处理工具部分的其他行
    else if (currentToolName && trimmedLine) {
      // 检查是否是响应开始的标识
      if (trimmedLine.includes('响应:') || trimmedLine.includes('响应：')) {
        // 提取响应内容
        const responseMatch = trimmedLine.match(/响应[:：]\s*(.+)/)
        if (responseMatch && responseMatch[1]) {
          currentToolOutput += responseMatch[1].trim() + '\n'
        }
      } 
      // 如果已经处于响应收集状态
      else if (currentToolOutput) {
        currentToolOutput += line + '\n'
      } 
      // 否则仍在输入参数收集状态
      else {
        currentToolInput += line + '\n'
      }
    }
    // 处理文本内容
    else if (trimmedLine) {
      // 保存工具块（如果有）
      if (currentToolName) {
        blocks.push({
          type: 'tool',
          name: currentToolName,
          input: currentToolInput.trim() || undefined,
          output: currentToolOutput.trim() || undefined,
          collapsed: false  // 默认展开工具调用信息
        })
        currentToolName = ''
        currentToolInput = ''
        currentToolOutput = ''
      }
      
      if (!currentBlock || currentBlock.type !== 'text') {
        if (currentBlock) {
          blocks.push(currentBlock)
        }
        
        currentBlock = {
          type: 'text',
          content: line
        }
      } else {
        currentBlock.content = currentBlock.content ? `${currentBlock.content}\n${line}` : line
      }
    }
  }
  
  // 保存最后的工具块（如果有）
  if (currentToolName) {
    blocks.push({
      type: 'tool',
      name: currentToolName,
      input: currentToolInput.trim() || undefined,
      output: currentToolOutput.trim() || undefined,
      collapsed: false  // 默认展开工具调用信息
    })
  }
  
  // 保存最后的块（如果有）
  if (currentBlock) {
    blocks.push(currentBlock)
  }
  
  contentBlocks.value = blocks
}

// 使用防抖更新，避免实时渲染导致的闪烁
watch(() => props.content, debouncedUpdateContentBlocks, { immediate: true, flush: 'post' })

</script>

<style scoped lang="scss">
.thinking-content-container {
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  max-width: 100%;
  position: relative;
  background: #ffffff;
}

.thinking-header {
  display: flex;
  align-items: center;
  padding: 12px 16px;
  background-color: #ffffff;
  border: 1px solid #e2e8f0;
  border-bottom: none;
  border-radius: 8px 8px 0 0;
  cursor: pointer;
  user-select: none;
  position: relative;
  font-size: 14px;
  font-weight: 500;
}

.thinking-header::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: #4299e1;
}

.thinking-icon {
  margin-right: 8px;
  color: #4299e1;
}

.thinking-title {
  font-weight: 600;
  color: #2d3748;
  margin-right: 8px;
  font-size: 16px;
}

.thinking-tag {
  margin-right: auto;
  background: #e2e8f0;
  color: #4a5568;
  border: none;
}

.collapse-icon {
  transition: transform 0.3s ease;
  color: #4a5568;
  
  &.is-collapsed {
    transform: rotate(-90deg);
  }
}

.thinking-content {
  border-top: 1px solid #e2e8f0;
  overflow-y: auto;
  background-color: #ffffff;
  border-radius: 0 0 8px 8px;
  border: 1px solid #e2e8f0;
  border-top: none;
}

/* 滚动条样式优化 */
.thinking-content::-webkit-scrollbar {
  width: 8px;
}

.thinking-content::-webkit-scrollbar-track {
  background: #f1f5f9;
  border-radius: 4px;
}

.thinking-content::-webkit-scrollbar-thumb {
  background: #4299e1;
  border-radius: 4px;
}

.thinking-content::-webkit-scrollbar-thumb:hover {
  background: #3182ce;
}

.formatted-content {
  padding: 12px 16px;
  background-color: #f8fafc;
  border: 1px solid #e2e8f0;
  border-radius: 6px;
  margin-bottom: 12px;
}

.content-block {
  width: 100%;
  max-width: 100%;
  margin-bottom: 12px;

  &:last-child {
    margin-bottom: 0;
  }
}

.text-block {
  box-sizing: border-box;
  display: block;
  width: 100%;
  padding: 12px 16px;
  background-color: #f8fafc;
  border: 1px solid #e2e8f0;
  border-radius: 6px;
  line-height: 1.5;
  color: #2d3748;
  font-size: 14px;
  white-space: pre-wrap;
  margin-bottom: 12px;
}

.tool-block {
  box-sizing: border-box;
  display: block;
  width: 100%;
  padding: 12px 16px;
  background-color: #f8fafc;
  border: 1px solid #e2e8f0;
  border-radius: 6px;
  margin-bottom: 12px;
  position: relative;
}

.tool-header {
  box-sizing: border-box;
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: center;
  width: 100%;
  padding: 0;
  background-color: transparent;
  cursor: pointer;
  user-select: none;
  border-bottom: none;
  margin-bottom: 8px;
  
  &:hover {
    background-color: transparent;
  }
}

.tool-icon {
  margin-right: 8px;
  color: #4299e1;
}

.tool-name {
  flex: 1;
  font-size: 14px;
  line-height: 1.5;
  color: #4299e1;
  padding: 4px 8px;
  background-color: #e6f7ff;
  border-radius: 4px;
  font-weight: 600;
}

.tool-data-toggle {
  padding: 4px 8px;
  font-size: 14px;
  color: #ffffff;
  cursor: pointer;
  border-radius: 4px;
  background: #4a5568;
  border: none;
  flex-shrink: 0;
  font-weight: 500;
  display: inline-block;
  margin-right: 0;
}

.tool-details {
  padding: 0;
  background-color: transparent;
}

.tool-section {
  margin-bottom: 16px;
}

.tool-section:last-child {
  margin-bottom: 0;
}

.section-title {
  box-sizing: border-box;
  font-size: 14px;
  font-weight: 600;
  color: #ffffff;
  padding: 6px 12px;
  background: #4299e1;
  border-radius: 16px;
  display: inline-block;
  margin-bottom: 8px;
}

.tool-input-json,
.tool-output-json {
  box-sizing: border-box;
  display: block;
  width: 100%;
  padding: 12px;
  margin-top: 8px;
  overflow-x: auto;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 13px;
  line-height: 1.5;
  color: #1e293b;
  word-break: break-all;
  word-wrap: break-word;
  white-space: pre-wrap;
  background: #ffffff;
  border: 1px solid #cbd5e0;
  border-radius: 4px;
  margin: 0;
}

.files-block {
  box-sizing: border-box;
  display: block;
  width: 100%;
  padding: 12px 16px;
  background-color: #f8fafc;
  border: 1px solid #e2e8f0;
  border-radius: 6px;
  margin-bottom: 12px;
  position: relative;
}

.files-header {
  display: flex;
  align-items: center;
  padding: 12px 16px;
  background-color: #f8fafc;
  cursor: pointer;
  user-select: none;
  border-bottom: 1px solid #e2e8f0;
  
  &:hover {
    background-color: #edf2f7;
  }
}

.files-icon {
  margin-right: 8px;
  color: #4299e1;
}

.files-title {
  font-weight: 600;
  color: #1a202c;
  flex-grow: 1;
  font-size: 14px;
}

.files-list {
  padding: 16px;
  background-color: #ffffff;
}

.file-item {
  display: flex;
  align-items: center;
  padding: 8px 0;
  color: #4a5568;
  font-size: 14px;
  line-height: 1.4;
  
  &:first-child {
    padding-top: 0;
  }
  
  &:last-child {
    padding-bottom: 0;
  }
}

.file-icon {
  margin-right: 8px;
  color: #718096;
}

.empty-content {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 40px 16px;
  color: #718096;
  font-style: italic;
  background: #f8fafc;
}

.empty-icon {
  margin-right: 8px;
  color: #a0aec0;
}

/* 动画 */
.fadeIn-enter-active {
  transition: opacity 0.3s ease;
}

.fadeIn-enter-from {
  opacity: 0;
}

.slideDown-enter-active,
.slideDown-leave-active {
  transition: all 0.3s ease;
  overflow: hidden;
}

.slideDown-enter-from,
.slideDown-leave-to {
  max-height: 0;
  opacity: 0;
}

.slideDown-enter-to,
.slideDown-leave-from {
  max-height: 1000px;
  opacity: 1;
}

/* 滚动条样式优化 - 与工作流事件保持一致 */
.tool-input-json::-webkit-scrollbar,
.tool-output-json::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

.tool-input-json::-webkit-scrollbar-track,
.tool-output-json::-webkit-scrollbar-track {
  background: #f1f5f9;
  border-radius: 4px;
}

.tool-input-json::-webkit-scrollbar-thumb,
.tool-output-json::-webkit-scrollbar-thumb {
  background: #4299e1;
  border-radius: 4px;
}

.tool-input-json::-webkit-scrollbar-thumb:hover,
.tool-output-json::-webkit-scrollbar-thumb:hover {
  background: #3182ce;
}
< / s t y l e > \ n \ n < / t e m p l a t e >  
 